/**
 * EVE Swagger Interface
 * An OpenAPI for EVE Online
 *
 * OpenAPI spec version: 0.5.5
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import io.swagger.client.model.Forbidden
import io.swagger.client.model.GetUniverseBloodlines200Ok
import io.swagger.client.model.GetUniverseCategoriesCategoryIdNotFound
import io.swagger.client.model.GetUniverseCategoriesCategoryIdOk
import io.swagger.client.model.GetUniverseConstellationsConstellationIdNotFound
import io.swagger.client.model.GetUniverseConstellationsConstellationIdOk
import io.swagger.client.model.GetUniverseFactions200Ok
import io.swagger.client.model.GetUniverseGraphicsGraphicIdNotFound
import io.swagger.client.model.GetUniverseGraphicsGraphicIdOk
import io.swagger.client.model.GetUniverseGroupsGroupIdNotFound
import io.swagger.client.model.GetUniverseGroupsGroupIdOk
import io.swagger.client.model.GetUniverseMoonsMoonIdNotFound
import io.swagger.client.model.GetUniverseMoonsMoonIdOk
import io.swagger.client.model.GetUniversePlanetsPlanetIdNotFound
import io.swagger.client.model.GetUniversePlanetsPlanetIdOk
import io.swagger.client.model.GetUniverseRaces200Ok
import io.swagger.client.model.GetUniverseRegionsRegionIdNotFound
import io.swagger.client.model.GetUniverseRegionsRegionIdOk
import io.swagger.client.model.GetUniverseStargatesStargateIdNotFound
import io.swagger.client.model.GetUniverseStargatesStargateIdOk
import io.swagger.client.model.GetUniverseStarsStarIdOk
import io.swagger.client.model.GetUniverseStationsStationIdNotFound
import io.swagger.client.model.GetUniverseStationsStationIdOk
import io.swagger.client.model.GetUniverseStructuresStructureIdNotFound
import io.swagger.client.model.GetUniverseStructuresStructureIdOk
import io.swagger.client.model.GetUniverseSystemJumps200Ok
import io.swagger.client.model.GetUniverseSystemKills200Ok
import io.swagger.client.model.GetUniverseSystemsSystemIdNotFound
import io.swagger.client.model.GetUniverseSystemsSystemIdOk
import io.swagger.client.model.GetUniverseTypesTypeIdNotFound
import io.swagger.client.model.GetUniverseTypesTypeIdOk
import io.swagger.client.model.InternalServerError
import io.swagger.client.model.PostUniverseNames200Ok
import io.swagger.client.model.PostUniverseNamesNotFound
import io.swagger.client.ApiInvoker
import io.swagger.client.ApiException
import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart
import javax.ws.rs.core.MediaType
import java.io.File
import java.util.Date

import scala.collection.mutable
import scala.collection.mutable.HashMap

class UniverseApi(val defBasePath: String = "https://esi.tech.ccp.is/latest",
                        defApiInvoker: ApiInvoker = ApiInvoker) {
  var basePath = defBasePath
  var apiInvoker = defApiInvoker

  def addHeader(key: String, value: String) = apiInvoker.defaultHeaders += key -> value 

  /**
   * Get bloodlines
   * Get a list of bloodlines  --- Alternate route: &#x60;/v1/universe/bloodlines/&#x60;  Alternate route: &#x60;/legacy/universe/bloodlines/&#x60;  Alternate route: &#x60;/dev/universe/bloodlines/&#x60;  --- This route expires daily at 11:05
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param language Language to use in the response (optional, default to en-us)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return List[GetUniverseBloodlines200Ok]
   */
  def getUniverseBloodlines(datasource: Option[String] = Some("tranquility"), language: Option[String] = Some("ru"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[List[GetUniverseBloodlines200Ok]] = {
    // create path and map variables
    val path = "/universe/bloodlines/".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    language.map(paramVal => queryParams += "language" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "array", classOf[GetUniverseBloodlines200Ok]).asInstanceOf[List[GetUniverseBloodlines200Ok]])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get item categories
   * Get a list of item categories  --- Alternate route: &#x60;/v1/universe/categories/&#x60;  Alternate route: &#x60;/legacy/universe/categories/&#x60;  Alternate route: &#x60;/dev/universe/categories/&#x60;  --- This route expires daily at 11:05
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return List[Int]
   */
  def getUniverseCategories(datasource: Option[String] = Some("tranquility"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[List[Int]] = {
    // create path and map variables
    val path = "/universe/categories/".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "array", classOf[Int]).asInstanceOf[List[Int]])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get item category information
   * Get information of an item category  --- Alternate route: &#x60;/v1/universe/categories/{category_id}/&#x60;  Alternate route: &#x60;/legacy/universe/categories/{category_id}/&#x60;  Alternate route: &#x60;/dev/universe/categories/{category_id}/&#x60;  --- This route expires daily at 11:05
   * @param categoryId An Eve item category ID 
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param language Language to use in the response (optional, default to en-us)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return GetUniverseCategoriesCategoryIdOk
   */
  def getUniverseCategoriesCategoryId(categoryId: Int, datasource: Option[String] = Some("tranquility"), language: Option[String] = Some("ru"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[GetUniverseCategoriesCategoryIdOk] = {
    // create path and map variables
    val path = "/universe/categories/{category_id}/".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "category_id" + "\\}",apiInvoker.escape(categoryId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    language.map(paramVal => queryParams += "language" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[GetUniverseCategoriesCategoryIdOk]).asInstanceOf[GetUniverseCategoriesCategoryIdOk])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get constellations
   * Get a list of constellations  --- Alternate route: &#x60;/v1/universe/constellations/&#x60;  Alternate route: &#x60;/legacy/universe/constellations/&#x60;  Alternate route: &#x60;/dev/universe/constellations/&#x60;  --- This route expires daily at 11:05
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return List[Int]
   */
  def getUniverseConstellations(datasource: Option[String] = Some("tranquility"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[List[Int]] = {
    // create path and map variables
    val path = "/universe/constellations/".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "array", classOf[Int]).asInstanceOf[List[Int]])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get constellation information
   * Get information on a constellation  --- Alternate route: &#x60;/v1/universe/constellations/{constellation_id}/&#x60;  Alternate route: &#x60;/legacy/universe/constellations/{constellation_id}/&#x60;  Alternate route: &#x60;/dev/universe/constellations/{constellation_id}/&#x60;  --- This route expires daily at 11:05
   * @param constellationId constellation_id Int
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param language Language to use in the response (optional, default to en-us)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return GetUniverseConstellationsConstellationIdOk
   */
  def getUniverseConstellationsConstellationId(constellationId: Int, datasource: Option[String] = Some("tranquility"), language: Option[String] = Some("ru"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[GetUniverseConstellationsConstellationIdOk] = {
    // create path and map variables
    val path = "/universe/constellations/{constellation_id}/".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "constellation_id" + "\\}",apiInvoker.escape(constellationId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    language.map(paramVal => queryParams += "language" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[GetUniverseConstellationsConstellationIdOk]).asInstanceOf[GetUniverseConstellationsConstellationIdOk])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get factions
   * Get a list of factions  --- Alternate route: &#x60;/v1/universe/factions/&#x60;  Alternate route: &#x60;/legacy/universe/factions/&#x60;  Alternate route: &#x60;/dev/universe/factions/&#x60;  --- This route expires daily at 11:05
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param language Language to use in the response (optional, default to en-us)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return List[GetUniverseFactions200Ok]
   */
  def getUniverseFactions(datasource: Option[String] = Some("tranquility"), language: Option[String] = Some("ru"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[List[GetUniverseFactions200Ok]] = {
    // create path and map variables
    val path = "/universe/factions/".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    language.map(paramVal => queryParams += "language" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "array", classOf[GetUniverseFactions200Ok]).asInstanceOf[List[GetUniverseFactions200Ok]])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get graphics
   * Get a list of graphics  --- Alternate route: &#x60;/v1/universe/graphics/&#x60;  Alternate route: &#x60;/legacy/universe/graphics/&#x60;  Alternate route: &#x60;/dev/universe/graphics/&#x60;  --- This route expires daily at 11:05
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return List[Int]
   */
  def getUniverseGraphics(datasource: Option[String] = Some("tranquility"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[List[Int]] = {
    // create path and map variables
    val path = "/universe/graphics/".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "array", classOf[Int]).asInstanceOf[List[Int]])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get graphic information
   * Get information on a graphic  --- Alternate route: &#x60;/v1/universe/graphics/{graphic_id}/&#x60;  Alternate route: &#x60;/legacy/universe/graphics/{graphic_id}/&#x60;  Alternate route: &#x60;/dev/universe/graphics/{graphic_id}/&#x60;  --- This route expires daily at 11:05
   * @param graphicId graphic_id Int
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return GetUniverseGraphicsGraphicIdOk
   */
  def getUniverseGraphicsGraphicId(graphicId: Int, datasource: Option[String] = Some("tranquility"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[GetUniverseGraphicsGraphicIdOk] = {
    // create path and map variables
    val path = "/universe/graphics/{graphic_id}/".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "graphic_id" + "\\}",apiInvoker.escape(graphicId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[GetUniverseGraphicsGraphicIdOk]).asInstanceOf[GetUniverseGraphicsGraphicIdOk])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get item groups
   * Get a list of item groups  --- Alternate route: &#x60;/v1/universe/groups/&#x60;  Alternate route: &#x60;/legacy/universe/groups/&#x60;  Alternate route: &#x60;/dev/universe/groups/&#x60;  --- This route expires daily at 11:05
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param page Which page of results to return (optional, default to 1)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return List[Int]
   */
  def getUniverseGroups(datasource: Option[String] = Some("tranquility"), page: Option[Int] /* = 1*/, userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[List[Int]] = {
    // create path and map variables
    val path = "/universe/groups/".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    page.map(paramVal => queryParams += "page" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "array", classOf[Int]).asInstanceOf[List[Int]])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get item group information
   * Get information on an item group  --- Alternate route: &#x60;/v1/universe/groups/{group_id}/&#x60;  Alternate route: &#x60;/legacy/universe/groups/{group_id}/&#x60;  Alternate route: &#x60;/dev/universe/groups/{group_id}/&#x60;  --- This route expires daily at 11:05
   * @param groupId An Eve item group ID 
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param language Language to use in the response (optional, default to en-us)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return GetUniverseGroupsGroupIdOk
   */
  def getUniverseGroupsGroupId(groupId: Int, datasource: Option[String] = Some("tranquility"), language: Option[String] = Some("ru"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[GetUniverseGroupsGroupIdOk] = {
    // create path and map variables
    val path = "/universe/groups/{group_id}/".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "group_id" + "\\}",apiInvoker.escape(groupId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    language.map(paramVal => queryParams += "language" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[GetUniverseGroupsGroupIdOk]).asInstanceOf[GetUniverseGroupsGroupIdOk])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get moon information
   * Get information on a moon  --- Alternate route: &#x60;/v1/universe/moons/{moon_id}/&#x60;  Alternate route: &#x60;/legacy/universe/moons/{moon_id}/&#x60;  Alternate route: &#x60;/dev/universe/moons/{moon_id}/&#x60;  --- This route expires daily at 11:05
   * @param moonId moon_id Int
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return GetUniverseMoonsMoonIdOk
   */
  def getUniverseMoonsMoonId(moonId: Int, datasource: Option[String] = Some("tranquility"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[GetUniverseMoonsMoonIdOk] = {
    // create path and map variables
    val path = "/universe/moons/{moon_id}/".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "moon_id" + "\\}",apiInvoker.escape(moonId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[GetUniverseMoonsMoonIdOk]).asInstanceOf[GetUniverseMoonsMoonIdOk])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get planet information
   * Get information on a planet  --- Alternate route: &#x60;/v1/universe/planets/{planet_id}/&#x60;  Alternate route: &#x60;/legacy/universe/planets/{planet_id}/&#x60;  Alternate route: &#x60;/dev/universe/planets/{planet_id}/&#x60;  --- This route expires daily at 11:05
   * @param planetId planet_id Int
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return GetUniversePlanetsPlanetIdOk
   */
  def getUniversePlanetsPlanetId(planetId: Int, datasource: Option[String] = Some("tranquility"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[GetUniversePlanetsPlanetIdOk] = {
    // create path and map variables
    val path = "/universe/planets/{planet_id}/".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "planet_id" + "\\}",apiInvoker.escape(planetId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[GetUniversePlanetsPlanetIdOk]).asInstanceOf[GetUniversePlanetsPlanetIdOk])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get character races
   * Get a list of character races  --- Alternate route: &#x60;/v1/universe/races/&#x60;  Alternate route: &#x60;/legacy/universe/races/&#x60;  Alternate route: &#x60;/dev/universe/races/&#x60;  --- This route expires daily at 11:05
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param language Language to use in the response (optional, default to en-us)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return List[GetUniverseRaces200Ok]
   */
  def getUniverseRaces(datasource: Option[String] = Some("tranquility"), language: Option[String] = Some("ru"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[List[GetUniverseRaces200Ok]] = {
    // create path and map variables
    val path = "/universe/races/".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    language.map(paramVal => queryParams += "language" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "array", classOf[GetUniverseRaces200Ok]).asInstanceOf[List[GetUniverseRaces200Ok]])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get regions
   * Get a list of regions  --- Alternate route: &#x60;/v1/universe/regions/&#x60;  Alternate route: &#x60;/legacy/universe/regions/&#x60;  Alternate route: &#x60;/dev/universe/regions/&#x60;  --- This route expires daily at 11:05
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return List[Int]
   */
  def getUniverseRegions(datasource: Option[String] = Some("tranquility"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[List[Int]] = {
    // create path and map variables
    val path = "/universe/regions/".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "array", classOf[Int]).asInstanceOf[List[Int]])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get region information
   * Get information on a region  --- Alternate route: &#x60;/v1/universe/regions/{region_id}/&#x60;  Alternate route: &#x60;/legacy/universe/regions/{region_id}/&#x60;  Alternate route: &#x60;/dev/universe/regions/{region_id}/&#x60;  --- This route expires daily at 11:05
   * @param regionId region_id Int
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param language Language to use in the response (optional, default to en-us)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return GetUniverseRegionsRegionIdOk
   */
  def getUniverseRegionsRegionId(regionId: Int,
                                 datasource: Option[String] = Some("tranquility"),
                                 language: Option[String] = Some("ru"),
                                 userAgent: Option[String] = None,
                                 xUserAgent: Option[String] = None): Option[GetUniverseRegionsRegionIdOk] = {
    // create path and map variables
    val path = "/universe/regions/{region_id}/".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "region_id" + "\\}",apiInvoker.escape(regionId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    language.map(paramVal => queryParams += "language" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[GetUniverseRegionsRegionIdOk]).asInstanceOf[GetUniverseRegionsRegionIdOk])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get stargate information
   * Get information on a stargate  --- Alternate route: &#x60;/v1/universe/stargates/{stargate_id}/&#x60;  Alternate route: &#x60;/legacy/universe/stargates/{stargate_id}/&#x60;  Alternate route: &#x60;/dev/universe/stargates/{stargate_id}/&#x60;  --- This route expires daily at 11:05
   * @param stargateId stargate_id Int
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return GetUniverseStargatesStargateIdOk
   */
  def getUniverseStargatesStargateId(stargateId: Int, datasource: Option[String] = Some("tranquility"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[GetUniverseStargatesStargateIdOk] = {
    // create path and map variables
    val path = "/universe/stargates/{stargate_id}/".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "stargate_id" + "\\}",apiInvoker.escape(stargateId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[GetUniverseStargatesStargateIdOk]).asInstanceOf[GetUniverseStargatesStargateIdOk])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get star information
   * Get information on a star  --- Alternate route: &#x60;/v1/universe/stars/{star_id}/&#x60;  Alternate route: &#x60;/legacy/universe/stars/{star_id}/&#x60;  Alternate route: &#x60;/dev/universe/stars/{star_id}/&#x60;  --- This route expires daily at 11:05
   * @param starId star_id Int
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return GetUniverseStarsStarIdOk
   */
  def getUniverseStarsStarId(starId: Int, datasource: Option[String] = Some("tranquility"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[GetUniverseStarsStarIdOk] = {
    // create path and map variables
    val path = "/universe/stars/{star_id}/".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "star_id" + "\\}",apiInvoker.escape(starId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[GetUniverseStarsStarIdOk]).asInstanceOf[GetUniverseStarsStarIdOk])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get station information
   * Get information on a station  --- Alternate route: &#x60;/v2/universe/stations/{station_id}/&#x60;  Alternate route: &#x60;/dev/universe/stations/{station_id}/&#x60;  --- This route is cached for up to 300 seconds
   * @param stationId station_id Int
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return GetUniverseStationsStationIdOk
   */
  def getUniverseStationsStationId(stationId: Int, datasource: Option[String] = Some("tranquility"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[GetUniverseStationsStationIdOk] = {
    // create path and map variables
    val path = "/universe/stations/{station_id}/".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "station_id" + "\\}",apiInvoker.escape(stationId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[GetUniverseStationsStationIdOk]).asInstanceOf[GetUniverseStationsStationIdOk])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * List all public structures
   * List all public structures  --- Alternate route: &#x60;/v1/universe/structures/&#x60;  Alternate route: &#x60;/legacy/universe/structures/&#x60;  Alternate route: &#x60;/dev/universe/structures/&#x60;  --- This route is cached for up to 3600 seconds
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return List[Long]
   */
  def getUniverseStructures(datasource: Option[String] = Some("tranquility"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[List[Long]] = {
    // create path and map variables
    val path = "/universe/structures/".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "array", classOf[Long]).asInstanceOf[List[Long]])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get structure information
   * Returns information on requested structure, if you are on the ACL. Otherwise, returns \&quot;Forbidden\&quot; for all inputs.  --- Alternate route: &#x60;/v1/universe/structures/{structure_id}/&#x60;  Alternate route: &#x60;/legacy/universe/structures/{structure_id}/&#x60;  Alternate route: &#x60;/dev/universe/structures/{structure_id}/&#x60;  --- This route is cached for up to 3600 seconds
   * @param structureId An Eve structure ID 
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param token Access token to use if unable to set a header (optional)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return GetUniverseStructuresStructureIdOk
   */
  def getUniverseStructuresStructureId(structureId: Long, datasource: Option[String] = Some("tranquility"), token: Option[String] = None, userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[GetUniverseStructuresStructureIdOk] = {
    // create path and map variables
    val path = "/universe/structures/{structure_id}/".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "structure_id" + "\\}",apiInvoker.escape(structureId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    token.map(paramVal => queryParams += "token" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[GetUniverseStructuresStructureIdOk]).asInstanceOf[GetUniverseStructuresStructureIdOk])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get system jumps
   * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  --- Alternate route: &#x60;/v1/universe/system_jumps/&#x60;  Alternate route: &#x60;/legacy/universe/system_jumps/&#x60;  Alternate route: &#x60;/dev/universe/system_jumps/&#x60;  --- This route is cached for up to 3600 seconds
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return List[GetUniverseSystemJumps200Ok]
   */
  def getUniverseSystemJumps(datasource: Option[String] = Some("tranquility"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[List[GetUniverseSystemJumps200Ok]] = {
    // create path and map variables
    val path = "/universe/system_jumps/".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "array", classOf[GetUniverseSystemJumps200Ok]).asInstanceOf[List[GetUniverseSystemJumps200Ok]])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get system kills
   * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  --- Alternate route: &#x60;/v2/universe/system_kills/&#x60;  Alternate route: &#x60;/dev/universe/system_kills/&#x60;  --- This route is cached for up to 3600 seconds
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return List[GetUniverseSystemKills200Ok]
   */
  def getUniverseSystemKills(datasource: Option[String] = Some("tranquility"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[List[GetUniverseSystemKills200Ok]] = {
    // create path and map variables
    val path = "/universe/system_kills/".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "array", classOf[GetUniverseSystemKills200Ok]).asInstanceOf[List[GetUniverseSystemKills200Ok]])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get solar systems
   * Get a list of solar systems  --- Alternate route: &#x60;/v1/universe/systems/&#x60;  Alternate route: &#x60;/legacy/universe/systems/&#x60;  Alternate route: &#x60;/dev/universe/systems/&#x60;  --- This route expires daily at 11:05
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return List[Int]
   */
  def getUniverseSystems(datasource: Option[String] = Some("tranquility"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[List[Int]] = {
    // create path and map variables
    val path = "/universe/systems/".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "array", classOf[Int]).asInstanceOf[List[Int]])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get solar system information
   * Get information on a solar system  --- Alternate route: &#x60;/v2/universe/systems/{system_id}/&#x60;  --- This route expires daily at 11:05
   * @param systemId system_id Int
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param language Language to use in the response (optional, default to en-us)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return GetUniverseSystemsSystemIdOk
   */
  def getUniverseSystemsSystemId(systemId: Int, datasource: Option[String] = Some("tranquility"), language: Option[String] = Some("ru"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[GetUniverseSystemsSystemIdOk] = {
    // create path and map variables
    val path = "/universe/systems/{system_id}/".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "system_id" + "\\}",apiInvoker.escape(systemId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    language.map(paramVal => queryParams += "language" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[GetUniverseSystemsSystemIdOk]).asInstanceOf[GetUniverseSystemsSystemIdOk])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get types
   * Get a list of type ids  --- Alternate route: &#x60;/v1/universe/types/&#x60;  Alternate route: &#x60;/legacy/universe/types/&#x60;  Alternate route: &#x60;/dev/universe/types/&#x60;  --- This route expires daily at 11:05
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param page Which page of results to return (optional, default to 1)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return List[Int]
   */
  def getUniverseTypes(datasource: Option[String] = Some("tranquility"),
                       page: Option[Int] = Some(1),
                       userAgent: Option[String] = None,
                       xUserAgent: Option[String] = None): Option[List[Int]] = {
    // create path and map variables
    val path = "/universe/types/".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    page.map(paramVal => queryParams += "page" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "array", classOf[Int]).asInstanceOf[List[Int]])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get type information
   * Get information on a type  --- Alternate route: &#x60;/v2/universe/types/{type_id}/&#x60;  Alternate route: &#x60;/legacy/universe/types/{type_id}/&#x60;  --- This route expires daily at 11:05
   * @param typeId An Eve item type ID 
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param language Language to use in the response (optional, default to en-us)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return GetUniverseTypesTypeIdOk
   */
  def getUniverseTypesTypeId(typeId: Int, datasource: Option[String] = Some("tranquility"), language: Option[String] = Some("ru"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[GetUniverseTypesTypeIdOk] = {
    // create path and map variables
    val path = "/universe/types/{type_id}/".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "type_id" + "\\}",apiInvoker.escape(typeId))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    language.map(paramVal => queryParams += "language" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[GetUniverseTypesTypeIdOk]).asInstanceOf[GetUniverseTypesTypeIdOk])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * Get names and categories for a set of ID&#39;s
   * Resolve a set of IDs to names and categories. Supported ID&#39;s for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types.  --- Alternate route: &#x60;/v2/universe/names/&#x60;  Alternate route: &#x60;/dev/universe/names/&#x60; 
   * @param ids The ids to resolve 
   * @param datasource The server name you would like data from (optional, default to tranquility)
   * @param userAgent Client identifier, takes precedence over headers (optional)
   * @param xUserAgent Client identifier, takes precedence over User-Agent (optional)
   * @return List[PostUniverseNames200Ok]
   */
  def postUniverseNames(ids: List[Int], datasource: Option[String] = Some("tranquility"), userAgent: Option[String] = None, xUserAgent: Option[String] = None): Option[List[PostUniverseNames200Ok]] = {
    // create path and map variables
    val path = "/universe/names/".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes.head

    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]
    val formParams = new mutable.HashMap[String, String]

    if (ids == null) throw new Exception("Missing required parameter 'ids' when calling UniverseApi->postUniverseNames")

    datasource.map(paramVal => queryParams += "datasource" -> paramVal.toString)
    userAgent.map(paramVal => queryParams += "user_agent" -> paramVal.toString)
    
    xUserAgent.map(paramVal => headerParams += "X-User-Agent" -> paramVal)

    var postBody: AnyRef = ids

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "array", classOf[PostUniverseNames200Ok]).asInstanceOf[List[PostUniverseNames200Ok]])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

}
